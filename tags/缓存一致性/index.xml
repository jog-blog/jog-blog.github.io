<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>缓存一致性 on Inkchron</title>
    <link>https://www.bmsg.top/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</link>
    <description>Recent content in 缓存一致性 on Inkchron</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 14 Nov 2025 07:10:00 +0800</lastBuildDate>
    <atom:link href="https://www.bmsg.top/tags/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>30W&#43; QPS商品系统缓存一致性解决方案深度解析</title>
      <link>https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/</link>
      <pubDate>Fri, 14 Nov 2025 07:10:00 +0800</pubDate>
      <guid>https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在电商业务中，商品服务作为核心业务模块，承担着极高的性能要求。面对30W+ QPS的并发压力，如何保证缓存与数据库的一致性成为系统设计的核心挑战。本文将深入探讨一套完整的缓存一致性解决方案。&lt;/p&gt;&#xA;&lt;h2 id=&#34;背景与挑战&#34;&gt;背景与挑战&lt;/h2&gt;&#xA;&lt;p&gt;商品系统在电商平台中定位为高性能、高并发、高可用的核心服务。在实际业务中，平均QPS达到3W+，大促期间更是飙升至30W+，而服务响应时间仍需控制在1.5ms左右。&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/qps-performance.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;商品服务QPS与性能监控图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;如此高的并发压力下，单纯依赖数据库显然无法满足性能要求。因此，引入Redis集群成为必然选择，但这也带来了缓存与数据库一致性的新挑战。&lt;/p&gt;&#xA;&lt;h2 id=&#34;缓存架构设计&#34;&gt;缓存架构设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;读操作流程&#34;&gt;读操作流程&lt;/h3&gt;&#xA;&lt;p&gt;商品读操作采用经典的缓存优先策略：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先查询Redis缓存&lt;/li&gt;&#xA;&lt;li&gt;缓存命中则直接返回数据&lt;/li&gt;&#xA;&lt;li&gt;缓存未命中则查询数据库&lt;/li&gt;&#xA;&lt;li&gt;将查询结果写入缓存&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/read-flow.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;商品读操作流程图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;写操作流程&#34;&gt;写操作流程&lt;/h3&gt;&#xA;&lt;p&gt;写操作采用先更新数据库再删除缓存的策略：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;更新数据库中的商品信息&lt;/li&gt;&#xA;&lt;li&gt;删除Redis中的对应缓存&lt;/li&gt;&#xA;&lt;li&gt;确保后续读请求能够获取最新数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/write-flow.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;商品写操作流程图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h2 id=&#34;缓存不一致问题分析&#34;&gt;缓存不一致问题分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;问题根源&#34;&gt;问题根源&lt;/h3&gt;&#xA;&lt;p&gt;缓存不一致主要源于两个核心问题：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;1. 网络抖动导致的删除失败&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;商品服务与缓存服务通过网络交互&lt;/li&gt;&#xA;&lt;li&gt;网络抖动可能导致操作超时&lt;/li&gt;&#xA;&lt;li&gt;缓存删除失败造成数据不一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;2. 多线程并发操作导致的数据覆盖&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询请求与更新请求并发执行&lt;/li&gt;&#xA;&lt;li&gt;时序问题导致旧数据覆盖新数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/cache-inconsistency.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;缓存不一致问题示意图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;典型场景分析&#34;&gt;典型场景分析&lt;/h3&gt;&#xA;&lt;p&gt;假设Redis中没有A商品的缓存：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;查询请求发现缓存未命中，开始查询数据库&lt;/li&gt;&#xA;&lt;li&gt;更新请求同时到达，更新数据库后删除缓存&lt;/li&gt;&#xA;&lt;li&gt;查询请求将旧数据写入缓存&lt;/li&gt;&#xA;&lt;li&gt;结果：缓存中保存的是更新前的旧数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;延时双删解决方案&#34;&gt;延时双删解决方案&lt;/h2&gt;&#xA;&lt;h3 id=&#34;核心思想&#34;&gt;核心思想&lt;/h3&gt;&#xA;&lt;p&gt;延时双删的核心思想是&amp;quot;过一会再删一次缓存&amp;quot;，通过两次删除操作确保缓存一致性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;方案优势&#34;&gt;方案优势&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;解决网络抖动问题&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一次删除失败，第二次删除大概率成功&lt;/li&gt;&#xA;&lt;li&gt;配合重试策略，确保最终一致性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;解决并发覆盖问题&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在不一致数据写入缓存后再次删除&lt;/li&gt;&#xA;&lt;li&gt;关键：延时时间的选择&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/delay-double-delete.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;延时双删触发机制图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;架构设计&#34;&gt;架构设计&lt;/h3&gt;&#xA;&lt;h4 id=&#34;服务解耦&#34;&gt;服务解耦&lt;/h4&gt;&#xA;&lt;p&gt;延时双删逻辑不应与商品核心服务强耦合，而是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;独立部署为单独服务&lt;/li&gt;&#xA;&lt;li&gt;通过监听商品Binlog的MQ实现解耦&lt;/li&gt;&#xA;&lt;li&gt;保证核心业务的纯粹性&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;触发机制&#34;&gt;触发机制&lt;/h4&gt;&#xA;&lt;p&gt;采用监听Binlog的MQ方案：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;商品更新时产生Binlog&lt;/li&gt;&#xA;&lt;li&gt;MQ监听Binlog变化&lt;/li&gt;&#xA;&lt;li&gt;触发延时双删服务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://www.bmsg.top/posts/tech/30w-qps-product-system-cache-consistency/images/binlog-mq-trigger.svg&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;h4&gt;Binlog监听触发机制图&lt;/h4&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;h3 id=&#34;延时时间选择&#34;&gt;延时时间选择&lt;/h3&gt;&#xA;&lt;h4 id=&#34;网络抖动场景&#34;&gt;网络抖动场景&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;延时时间越短越好&lt;/li&gt;&#xA;&lt;li&gt;减少数据不一致的时间窗口&lt;/li&gt;&#xA;&lt;li&gt;通常设置为毫秒级别&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;并发覆盖场景&#34;&gt;并发覆盖场景&lt;/h4&gt;&#xA;&lt;p&gt;延时时间需要大于&amp;quot;读周期&amp;quot;：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
